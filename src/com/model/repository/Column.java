package com.model.repository;

import com.events.Dispatcher;
import com.intf.callable.CallableEx1;
import com.model.repository.intf.Align;
import com.intf.runnable.Runnable1;
import com.intf.runnable.RunnableEx1;
import com.intf.runnable.RunnableEx2;
import com.intf.runnable.RunnableEx3;
import com.json.JObject;
import com.model.repository.intf.CaseConvert;
import com.utils.Is;
import com.utils.Utils;
import com.utils.collections.TList;
import com.utils.reflections.datatype.DataType;
import java.util.LinkedHashMap;
import java.util.Objects;

public class Column<RAW> {

    public final RepoFieldConfig config = new RepoFieldConfig();

    public Column(Runnable1<RepoFieldConfig> cfg) {

        try {
            cfg.run(config);
        } catch (Throwable e) {
            throw new RepositoryException(null, cfg.getClass().getName(), e);
        }
        config.validate();
    }

    public String getKey() {
        return config.key;
    }

    public Column<RAW> config(Runnable1<RepoFieldConfig> cfg) {
        try {
            cfg.run(config);
        } catch (Throwable e) {
            throw new RepositoryException(null, cfg.getClass().getName(), e);
        }
        config.validate();
        return this;
    }

    RAW set(Record rec, final Object value) {
        Repository<?> repo = rec.repo;
        try {

            int idx = new TList<>(repo.columns.values()).indexOf(this);
            if (idx < 0)
                throw new RepositoryException(repo, "Repozytorium nie posiada kolumny " + getKey());

            config.onBeforeSet.dispatch(this, r -> r.run(rec, value));

            final Object value2 = value != null ? value : config.defaultValue;

            RAW val = config.parser != null
                    ? config.parser.run(value2)
                    : config.type.parse(value2);

            config.validate.dispatch(this, r -> r.run(val));

            if (value2 == null && Boolean.TRUE.equals(config.required))
                throw new RepositoryException(repo, "Wartość pola " + getKey() + " nie może być pusta");

            Object src = rec.cells[idx];
            if (!Objects.equals(src, val)) {
                rec.cells[idx] = val;
                config.onAfterSet.dispatch(this, r -> r.run(rec, val, null));
                rec.changed.add(this);
            }

            return val;
        } catch (Throwable e) {
            config.onAfterSet.dispatch(this, r -> r.run(rec, null, null));
            throw new RepositoryException(repo, repo.config.key + "." + getKey(), e);
        }
    }

    public JObject getJson() {
        return config.getJson();
    }

    public class RepoFieldConfig {

        public Class<? extends Repository<?>> repository;
        public DataType<? extends RAW> type;
        public Class<? extends RAW> clazz;
        public String key;

        public Boolean list;
        public Integer min;
        public Integer max;
        public Boolean trim;
        public String regex;
        public Align align;
        public CaseConvert caseConvert;
        public String allowedChars;
        /**
         * Wartość domyślna ustawiana, gdy pojawi się null
         */
        public Object defaultValue;
        /**
         * Tekst lub tablica nie mogą być puste
         */
        public Boolean nonEmpty;
        public Boolean autoGenerated;
        public Boolean readOnly;
        public Boolean required;
        public Boolean unique;
        public CharSequence name;
        public CharSequence title;
        public String daoName;
        public String daoType;
        //public Column<?> foreign;
        public CharSequence description;
        public final LinkedHashMap<String, String> enumerate = new LinkedHashMap<>();

        //----------------------------------------------------------------------
        public Boolean sortOrder; // true - rosnący, false malejący
        public CharSequence subtitle;
        public Boolean disabled; // kolumna niewidoczna, zawiera daodatkowe dane, nie można jej wyświetliś
        public Boolean hidden; // kolumna niewidoczna domyslnie (można wyświetlić z menu kontekstowego)
        public Boolean sortable; // można sortować
        public Boolean filtered; // można filtrowac po tej kolumnie
        public String dateFormat;
        public String[] dateFormats;
        public Boolean searchable;
        //----------------------------------------------------------------------
        public final Dispatcher<RunnableEx2<Record, Object>> onBeforeSet = new Dispatcher<>();
        public final Dispatcher<RunnableEx3<Record, RAW, Throwable>> onAfterSet = new Dispatcher<>();
        public CallableEx1<RAW, Object> parser;
        public final Dispatcher<RunnableEx1<RAW>> validate = new Dispatcher<>();

        public void validate() {

            Objects.requireNonNull(key, "Wymagane pole 'klucz'");
            Objects.requireNonNull(type, "Wymagane pole 'type'");

            if (clazz == null)
                clazz = (Class<? extends RAW>) type.clazz;

            if (Is.empty(daoName))
                daoName = key;

        }

        public JObject getJson() {
            JObject json = new JObject(key);
            json.options.singleLine(true);
            json.options.acceptNulls(false);

            json.put("key", key);
            json.put("name", name);
            json.put("gen", autoGenerated);
            json.put("hidden", hidden);
            json.put("readOnly", readOnly);
            json.put("required", required);
            json.put("unique", unique);

            json.put("desc", description);
            json.put("subtitle", subtitle);
            json.put("sortOrder", sortOrder);
            JObject jtype = type.getJson();
            jtype.options.singleLine(true);
            json.put("type", jtype);
            json.put("align", align != null ? align.key : null);
            json.put("searchable", searchable);
            json.put("filtered", filtered);
            json.put("disabled", disabled);
            json.put("sortable", sortable);
            return json;
        }

    }

}

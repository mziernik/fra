package com.model.repository;

import com.database.Database;
import com.database.QueryRows;
import com.database.model.DbUtils;
import com.database.queries.InsertOrUpdate;
import com.database.queries.MultipleQuery;
import com.database.queries.builder.QueryObject;
import com.exceptions.SQLError;
import com.servlet.Handlers;
import com.utils.Is;
import com.utils.collections.Pairs;
import com.utils.collections.TList;
import com.utils.text.StrWriter;
import java.sql.SQLException;
import java.util.*;

public class DbRepo<PRIMARY_KEY> extends Repository<PRIMARY_KEY> {

    /**
     * Schemat i nazwa tabeli
     */
    public final String tableName;
    protected final Pairs<RepoField<?>, Boolean> orderColumns = new Pairs<>(); // kolumna, ASC

    public DbRepo(String key, String tableName, CharSequence name, RepoField<PRIMARY_KEY> primaryKey) {
        super(key, name, primaryKey);
        this.tableName = tableName;
    }

    static void commitChanges(Collection<Record> records) throws Exception {

        Database db = Handlers.database.getInstance().getDatabase();

        Set<Repository<?>> repositories = new HashSet<>();
        db.transaction((d) -> {
            final Set<com.database.model.Repository> sortTables = new HashSet<>();

            MultipleQuery mqry = d.multipleQuery();

            TList<Record> update = new TList<>();
            TList<Record> delete = new TList<>();

            for (Record rec : records) {
                repositories.add(rec.repo);
                if (rec.crude == CRUDE.DELETE)
                    ((DbRepo) rec.repo).getDeleteQuery(mqry, delete.addR(rec));
                else
                    ((DbRepo) rec.repo).getUpdateQuery(mqry, update.addR(rec));
            }
            if (mqry.isEmpty())
                return;

            QueryRows rows = mqry.execute();

            DbUtils.processMarkers(rows, update, (qr, rec) -> {
                if (qr.size() != 1)
                    throw new SQLException("Unexpected results count (" + qr.size() + ")");

                rec.fillRow(Objects.requireNonNull(qr.first()));
                rec.repo.updateRecord(rec);
            });

            for (Record rec : delete)
                rec.repo.updateRecord(rec);

        });

        for (Repository<?> repo : repositories)
            repo.sort();

    }

    static void updateRecords(Collection<Record> records) throws Exception {

        Database db = Handlers.database.getInstance().getDatabase();

        MultipleQuery queries = db.multipleQuery();
        /*
        for (Record record : records) {
            com.database.model.Repository<?, ?> tbl = (com.database.model.Repository<?, ?>) ds;
            //DbRecord<?, ?> rec = tbl.recordClass.newInstance(null);

            MultipleQuery mqry = db.multipleQuery();
            tbl.getSelectQuery(mqry);

            if (!mqry.isEmpty())
                queries.add(DbUtils.addMarker(db, tbl)).add(mqry);

        }

        DbUtils.processMarkers(queries.execute(), repos1.values(), (rows, ds) -> {

            ds.fillRows(rows);
            Ready.confirm(ds.getClass());

        });*/
    }

    protected void getDeleteQuery(MultipleQuery mqry, Record rec) {
        mqry.query("DELETE FROM " + tableName + " WHERE "
                + primaryKey.getStoreName() + " = ?", rec.getPrimaryKeyValue());
    }

    protected void getSelectQuery(MultipleQuery mqry) {

        StrWriter sb = new StrWriter();
        for (RepoField<?> col : fields)
            sb.append(sb.length() == 0 ? "SELECT " : ", ")
                    .append(col.getStoreName());

        sb.append("\nFROM ")
                .append(tableName);

        if (!orderColumns.isEmpty())
            sb.append("\nORDER BY ")
                    .join(orderColumns, ", ", (p) -> p.first.getStoreName()
                    + (p.second ? " ASC" : " DESC"));
        mqry.query(sb.toString());
    }

    protected void getUpdateQuery(MultipleQuery mqry, Record record) throws SQLError {

        InsertOrUpdate ins = mqry.insertOrUpdate(tableName,
                record.crude == CRUDE.UPDATE ? record.repo.primaryKey.getStoreName() + " = ?" : null,
                record.getPrimaryKeyValue());

        for (RepoField<?> field : record.repo.fields) {

            ins.addReturningColumn(field.getStoreName());

            Object value = record.get(field);
            if (value == null && field.isAutoGenerated)
                continue;

            QueryObject obj = ins.put(field.getStoreName(), value).array(true);
            if (!Is.empty(field.getStoreType()))
                obj.cast(field.getStoreType());

        }

    }

}
